import fs from 'fs'
import path from 'path'
import createTemplateValues from './createTemplateValues'
import createDocComment from './createDocComment'
import { getDirentTree, DirentTree, FileData } from './getDirentTree'
import { version } from '.'
import type { AspidaConfig } from './getConfigs'

export const HTTP_METHODS = ['get', 'post', 'put', 'delete', 'patch'] as const

const listNotIndexFiles = (tree: DirentTree): string[] => [
  ...tree.children
    .filter(c => !c.name.startsWith('[') && !c.isDir && c.name !== 'index.ts')
    .map(
      c =>
        `${tree.path}/\u001b[31m${c.name}\u001b[0m -> \u001b[32m${c.name.replace(
          '.ts',
          ''
        )}/index.ts\u001b[0m`
    ),
  ...tree.children
    .map(c => (!c.name.startsWith('[') && c.isDir ? listNotIndexFiles(c.tree) : []))
    .reduce((p, c) => [...p, ...c], [])
]

const createTemplate = (
  tree: DirentTree,
  baseURL: string,
  trailingSlash: boolean,
  basePath: string,
  constantsPath: string | false,
  typesPath: string | false
) => {
  const { api, imports, pathes } = createTemplateValues(tree, basePath, trailingSlash)
  const formats = ['FormData', 'URLSearchParams', 'ArrayBuffer', 'Blob', 'string'].filter(f =>
    api.includes(`, option, ${f.toUpperCase()}),`)
  )
  const text = `/* $api.ts was generated by aspida@${version()} */
/* eslint-disable */
<% imports %>

type BasicHeaders = Record<string, string>

type Params = {
  query?: any
  headers?: any
  body?: any
  init?: RequestInit
}

const headersToObject = (headers: Headers): any =>
  [...headers.entries()].reduce((prev, [key, val]) => ({ ...prev, [key]: val }), {})
${
  formats.includes('FormData')
    ? `
const appendDataToFormData = (data: Record<string, any>, formData: FormData) => {
  Object.entries(data).forEach(([key, val]) => {
    if (Array.isArray(val)) {
      val.forEach(v => formData.append(key, v))
    } else if (val != null) {
      formData.append(key, val)
    }
  })

  return formData
}
`
    : ''
}${
    formats.includes('URLSearchParams') || api.includes('dataToURLString(')
      ? `
const dataToURLString = (data: Record<string, any>) => {
  const searchParams = new URLSearchParams()

  Object.entries(data).forEach(([key, val]) => {
    if (Array.isArray(val)) {
      val.forEach(v => searchParams.append(key, v))
    } else if (val != null) {
      searchParams.append(key, val)
    }
  })

  return searchParams.toString()
}
`
      : ''
  }${
    formats.length
      ? `\ntype Format = ${formats.map(f => `'${f}'`).join(' | ')}\n\n${formats
          .map(f => `const ${f.toUpperCase()} = '${f}'`)
          .join('\n')}`
      : ''
  }${
    formats.includes('FormData')
      ? "\nconst CommonFormData = typeof FormData !== 'undefined' ? FormData : require('form-data')"
      : ''
  }
const optionToRequest = (method: string, params?: Params${
    formats.length ? ', format?: Format' : ''
  }): RequestInit => {
  if (!params?.body) return { method, ...params?.init }

${
  formats.length
    ? `  let body
  let headers: BasicHeaders = {}

  switch (format) {
${
  formats.includes('FormData')
    ? `    case FORMDATA:
      const formData = new CommonFormData()
      body = appendDataToFormData(params.body, formData)
      headers = formData.getHeaders?.()
      break
`
    : ''
}${
        formats.includes('URLSearchParams')
          ? `    case URLSEARCHPARAMS:
      body = dataToURLString(params.body)
      headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8'
      break
`
          : ''
      }${formats.includes('ArrayBuffer') ? '    case ARRAYBUFFER:\n' : ''}${
        formats.includes('Blob') ? '    case BLOB:\n' : ''
      }${formats.includes('string') ? '    case STRING:\n' : ''}${
        formats.includes('ArrayBuffer') || formats.includes('Blob') || formats.includes('string')
          ? `
      body = params.body
      break
`
          : ''
      }    default:
      body = JSON.stringify(params.body)
      headers['Content-Type'] = 'application/json;charset=utf-8'
      break
  }

`
    : ''
}  return {
    method,
    body${formats.length ? '' : ': JSON.stringify(params.body)'},
    ...params.init,
    headers: { ${
      formats.length ? '...headers' : "'Content-Type': 'application/json;charset=utf-8'"
    }, ...params.init?.headers, ...params.headers }
  }
}

type ServerData = { status?: number; headers?: BasicHeaders; body?: any }
type ResType = 'json' | 'text' | 'arrayBuffer' | 'blob' | 'formData' | 'void'

const client: typeof fetch = typeof fetch !== 'undefined' ? fetch : require('node-fetch')
const send = async <
  Success extends ServerData = { status: number; headers: BasicHeaders },
  Failure extends ServerData = { status: number; headers: BasicHeaders }
>(
  method: string,
  baseURL: string,
  url: string,
  resType: ResType,
  errType: ResType,
  params?: Params${
    formats.length
      ? `,
  format?: Format`
      : ''
  }
): Promise<
  | { res: Success; err?: undefined }
  | { res?: undefined; err: { type: 'httpError'; data: Failure } }
  | { res?: undefined; err: { type: 'networkError'; data: TypeError } }
> => {
  try {
    const res = await client(
      \`\${baseURL}\${url}${
        api.includes('dataToURLString(')
          ? `\${params?.query ? \`?\${dataToURLString(params.query)}\` : ''}`
          : ''
      }\`,
      optionToRequest(method, params${formats.length ? ', format' : ''})
    )

    if (res.ok) {
      return {
        res: {
          status: res.status,
          headers: headersToObject(res.headers),
          body: resType === 'void' ? undefined : await res[resType]()
        } as Success
      }
    } else {
      return {
        err: {
          type: 'httpError',
          data: {
            status: res.status,
            headers: headersToObject(res.headers),
            body: errType === 'void' ? undefined : await res[errType]()
          } as Failure
        }
      }
    }
  } catch (e) {
    return { err: { type: 'networkError', data: e } }
  }
}

const BASE_URL = '<% baseURL %>'
${pathes.map((p, i) => `const PATH${i} = ${p}`).join('\n')}
${HTTP_METHODS.map(m => m.toUpperCase())
  .filter(m => api.includes(`(${m}, prefix,`))
  .map(m => `const ${m} = '${m}'`)
  .join('\n')}

${createDocComment(
  '',
  tree.children.find((c): c is FileData => !c.isDir && c.name === 'index.ts')?.doc
)}export const createApi = (config?: { baseURL?: string; trailingSlash?: boolean; init?: RequestInit }) => {
  const prefix = (config?.baseURL ?? BASE_URL).replace(/\\/$/, '')

  return <% api %> as const
}
${constantsPath ? `\nexport * from '${constantsPath}@constants'\n` : ''}${
    typesPath ? `\nexport * from '${typesPath}@types'\n` : ''
  }`
    .replace('<% imports %>', imports.join('\n'))
    .replace('<% api %>', api)
    .replace('<% baseURL %>', baseURL)
    .replace(/\n([a-z])/g, '\n// prettier-ignore\n$1')

  return { text, filePath: path.posix.join(tree.path, '$api.ts') }
}

export default ({ input, baseURL, trailingSlash, outputEachDir }: AspidaConfig) => {
  const direntTree = getDirentTree(input)
  const constantsPath =
    (fs.existsSync(`${input}/@constants/index.ts`) || fs.existsSync(`${input}/@constants.ts`)) &&
    './'
  const typesPath =
    (fs.existsSync(`${input}/@types/index.ts`) || fs.existsSync(`${input}/@types.ts`)) && './'
  const templates = [
    createTemplate(direntTree, baseURL, trailingSlash, '', constantsPath, typesPath)
  ]

  if (outputEachDir) {
    const notIndexFiles = listNotIndexFiles(direntTree)
    if (notIndexFiles.length) {
      console.log(`aspida \u001b[43m\u001b[31mERROR\u001b[0m Since true is specified in outputEachDir at aspida.config.js, you need to rename the following files
  ${notIndexFiles.join('\n  ')}`)

      return []
    }

    const appendTemplate = (
      tree: DirentTree,
      constantsPath: string | false,
      typesPath: string | false
    ) => {
      tree.children.forEach(c => {
        if (!c.isDir || c.name.startsWith('_')) return

        templates.push(
          createTemplate(
            c.tree,
            baseURL,
            trailingSlash,
            c.tree.path.replace(input, ''),
            constantsPath,
            typesPath
          )
        )

        appendTemplate(
          c.tree,
          constantsPath && `${constantsPath}../`,
          typesPath && `${typesPath}../`
        )
      })
    }

    appendTemplate(
      direntTree,
      constantsPath && `${constantsPath}../`,
      typesPath && `${typesPath}../`
    )
  }

  return templates
}
