/* $api.ts was generated by aspida@1.6.3 */
/* eslint-disable */
import type { Methods as Methods0 } from './[hogeId@number]'
import type { Methods as Methods1 } from './[hogeId@string]/entries.json'
import type { Methods as Methods2 } from './[hogeId@string]/test-4'
import type { Methods as Methods3 } from './[hogeId@string]/test-4/[fugaId]'
import type { Methods as Methods4 } from './[hogeId@string]/test-4/fuga aa'
import type { Methods as Methods5 } from './[hogeId]'

type BasicHeaders = Record<string, string>

type Params = {
  query?: any
  headers?: any
  body?: any
  init?: RequestInit
}

const headersToObject = (headers: Headers): any =>
  [...headers.entries()].reduce((prev, [key, val]) => ({ ...prev, [key]: val }), {})

const appendDataToFormData = (data: Record<string, any>, formData: FormData) => {
  Object.entries(data).forEach(([key, val]) => {
    if (Array.isArray(val)) {
      val.forEach(v => formData.append(key, v))
    } else if (val != null) {
      formData.append(key, val)
    }
  })

  return formData
}

const dataToURLString = (data: Record<string, any>) => {
  const searchParams = new URLSearchParams()

  Object.entries(data).forEach(([key, val]) => {
    if (Array.isArray(val)) {
      val.forEach(v => searchParams.append(key, v))
    } else if (val != null) {
      searchParams.append(key, val)
    }
  })

  return searchParams.toString()
}

const optionToRequest = (
  method: string,
  params?: Params,
  format?: BodyInit
): RequestInit => {
  if (!params) return { method }

  let body
  let headers: BasicHeaders = {}

  switch (format) {
    case undefined:
      break;
    case 'FormData':
      if (typeof FormData !== 'undefined') {
        body = appendDataToFormData(params.body, new FormData())
      } else {
        const formData = new (require('form-data'))()
        body = appendDataToFormData(params.body, formData)
        headers = formData.getHeaders()
      }
      break
    case 'URLSearchParams':
      body = dataToURLString(params.body)
      headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8'
      break
    case 'ArrayBuffer':
    case 'string':
    case 'Blob':
      body = params.body
      break
    default:
      body = JSON.stringify(params.body)
      headers['Content-Type'] = 'application/json;charset=utf-8'
      break
  }

  return { ...params.init, method, body, headers: { ...headers, ...params.init?.headers, ...params.headers } }
}

type ServerData = { status: number; headers: BasicHeaders; body?: any }

type NormalizedResponse<Success extends ServerData, Failure extends ServerData> =
  | { isSuccess: true; stream: Response['body']; data: Success }
  | { isSuccess: false; isFailure: true; stream: Response['body']; data: Failure }
  | { isSuccess: false; isFailure: false; err: Error };

const send = async <Success extends ServerData = { status: number; headers: BasicHeaders }, Failure extends ServerData = { status: number; headers: BasicHeaders }>(
  client: typeof fetch,
  method: string,
  baseURL: string,
  url: string,
  resType: 'json' | 'text' | 'arrayBuffer' | 'blob' | 'formData' | 'void',
  params?: Params,
  format?: BodyInit
): Promise<NormalizedResponse<Success, Failure>> => {
  try {
    const res = await client(
      `${baseURL}${url}${
        params?.query ? `?${dataToURLString(params.query)}` : ''
      }`,
      optionToRequest(method, params, format)
    )

    if (res.ok) {
      return {
        isSuccess: true,
        stream: res.body,
        data: {
          status: res.status,
          headers: headersToObject(res.headers),
          body: resType === 'void' ? undefined : await res[resType](),
        } as Success
      };
    } else {
      return {
        isSuccess: false,
        isFailure: true,
        stream: res.body,
        data: {
          status: res.status,
          headers: headersToObject(res.headers),
        } as Failure
      };
    }
  } catch (err) {
    return {
      isSuccess: false,
      isFailure: false,
      err,
    };
  }
}

export const createApi = (config?: { baseURL?: string; trailingSlash?: boolean; init?: RequestInit}) => {
  const f = typeof fetch !== 'undefined' ? fetch : require('node-fetch')
  const prefix = (config?.baseURL ?? '').replace(/\/$/, '')
  const PATH0 = '/v1.1/2'
  const PATH1 = '/entries.json'
  const PATH2 = '/test-4'
  const PATH3 = '/test-4/fuga aa'
  const GET = 'GET'
  const POST = 'POST'
  const PUT = 'PUT'
  const DELETE = 'DELETE'

  return {
    hogeId_number: (val0: number) => {
      const prefix0 = `${PATH0}/${val0}`

      return {
        $get: (option: { query?: Methods0['get']['query'], headers: Methods0['get']['reqHeaders'], config?: RequestInit }) =>
          send<Methods0['get']['resBody']>(f, GET, prefix, prefix0, 'json', option),
        $path: (option?: { method?: 'get'; query: Methods0['get']['query'] }) =>
          `${prefix}${prefix0}${option && option.query ? `?${dataToURLString(option.query)}` : ''}`
      }
    },
    hogeId_string: (val0: string) => {
      const prefix0 = `${PATH0}/${val0}`

      return {
        entries_json: {
          $get: (option?: { config?: RequestInit }) =>
            send<Methods1['get']['resBody']>(f, GET, prefix, `${prefix0}${PATH1}`, 'json', option),
          $path: () => `${prefix}${prefix0}${PATH1}`
        },
        test_4: {
          /**
           * _fugaId comment
           */
          fugaId: (val2: number | string) => {
            const prefix2 = `${prefix0}${PATH2}/${val2}`

            return {
              $get: (option?: { query?: Methods3['get']['query'], config?: RequestInit }) =>
                send<Methods3['get']['resBody']>(f, GET, prefix, prefix2, 'json', option),
              $post: (option: { body?: Methods3['post']['reqBody'], query: Methods3['post']['query'], config?: RequestInit }) =>
                send<Methods3['post']['resBody']>(f, POST, prefix, prefix2, 'json', option),
              $put: (option: { query: Methods3['put']['query'], config?: RequestInit }) =>
                send<Methods3['put']['resBody']>(f, PUT, prefix, prefix2, 'json', option),
              /**
               * _fugaId delete method
               * @returns _fugaId resBody
               */
              $delete: (option: { query: Methods3['delete']['query'], config?: RequestInit }) =>
                send<Methods3['delete']['resBody']>(f, DELETE, prefix, prefix2, 'json', option),
              $path: (option?: { method?: 'get'; query: Methods3['get']['query'] } | { method: 'post'; query: Methods3['post']['query'] } | { method: 'put'; query: Methods3['put']['query'] } | { method: 'delete'; query: Methods3['delete']['query'] }) =>
                `${prefix}${prefix2}${option && option.query ? `?${dataToURLString(option.query)}` : ''}`
            }
          },
          fuga_aa: {
            $get: (option: { query: Methods4['get']['query'], config?: RequestInit }) =>
              send<Methods4['get']['resBody']>(f, GET, prefix, `${prefix0}${PATH3}`, 'json', option),
            $post: (option: { body?: Methods4['post']['reqBody'], query: Methods4['post']['query'], config?: RequestInit }) =>
              send<Methods4['post']['resBody']>(f, POST, prefix, `${prefix0}${PATH3}`, 'json', option),
            $put: (option: { query: Methods4['put']['query'], config?: RequestInit }) =>
              send<Methods4['put']['resBody']>(f, PUT, prefix, `${prefix0}${PATH3}`, 'json', option),
            $delete: (option: { body: Methods4['delete']['reqBody'], query: Methods4['delete']['query'], config?: RequestInit }) =>
              send<Methods4['delete']['resBody']>(f, DELETE, prefix, `${prefix0}${PATH3}`, 'json', option),
            $path: (option?: { method?: 'get'; query: Methods4['get']['query'] } | { method: 'post'; query: Methods4['post']['query'] } | { method: 'put'; query: Methods4['put']['query'] } | { method: 'delete'; query: Methods4['delete']['query'] }) =>
              `${prefix}${prefix0}${PATH3}${option && option.query ? `?${dataToURLString(option.query)}` : ''}`
          },
          $get: (option: { query: Methods2['get']['query'], config?: RequestInit }) =>
            send<void>(f, GET, prefix, `${prefix0}${PATH2}`, 'void', option),
          $post: (option?: { body?: Methods2['post']['reqBody'], query?: Methods2['post']['query'], config?: RequestInit }) =>
            send<void>(f, POST, prefix, `${prefix0}${PATH2}`, 'void', option),
          $put: (option?: { query?: Methods2['put']['query'], config?: RequestInit }) =>
            send<Methods2['put']['resBody']>(f, PUT, prefix, `${prefix0}${PATH2}`, 'json', option),
          $delete: (option: { query: Methods2['delete']['query'], config?: RequestInit }) =>
            send<Methods2['delete']['resBody']>(f, DELETE, prefix, `${prefix0}${PATH2}`, 'json', option),
          $path: (option?: { method?: 'get'; query: Methods2['get']['query'] } | { method: 'post'; query: Methods2['post']['query'] } | { method: 'put'; query: Methods2['put']['query'] } | { method: 'delete'; query: Methods2['delete']['query'] }) =>
            `${prefix}${prefix0}${PATH2}${option && option.query ? `?${dataToURLString(option.query)}` : ''}`
        }
      }
    },
    hogeId: (val0: number | string) => {
      const prefix0 = `${PATH0}/${val0}`

      return {
        $get: (option?: { config?: RequestInit }) =>
          send<Methods5['get']['resBody']>(f, GET, prefix, prefix0, 'json', option),
        $path: () => `${prefix}${prefix0}`
      }
    }
  }
}

export * from './../../@constants'
export const api = createApi()
